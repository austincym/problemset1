# -*- coding: utf-8 -*-
"""problemset1cym

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JXKgnbNV0ZInDqrgi5MUQ4h1AH7HyPgO
"""

#### Load MNIST and show a montage of the images.

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# import numpy as np
# import matplotlib.pyplot as plt
# import torch
# from torchvision import datasets
# from skimage.util import montage
# from sklearn.metrics import accuracy_score
# !pip install wandb
# import wandb as wb
# from skimage.io import imread

def GPU(data):
    return torch.tensor(data, requires_grad=True, dtype=torch.float, device=torch.device('cuda'))

def GPU_data(data):
    return torch.tensor(data, requires_grad=False, dtype=torch.float, device=torch.device('cuda'))

def plot(x):
    if type(x) == torch.Tensor :
        x = x.cpu().detach().numpy()

    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(7, 7)
    plt.show()

def montage_plot(x):
    x = np.pad(x, pad_width=((0, 0), (1, 1), (1, 1)), mode='constant', constant_values=0)
    plot(montage(x))

train_set = datasets.MNIST('./data', train=True, download=True)
test_set = datasets.MNIST('./data', train=False, download=True)

X = train_set.data.numpy()
X_test = test_set.data.numpy()
Y = train_set.targets.numpy()
Y_test = test_set.targets.numpy()

X = X[:,None,:,:]/255
X_test = X_test[:,None,:,:]/255

X.shape

x = X[3,0,:,:]

montage_plot(X[125:150,0,:,:])

#### Run a random y=mx model on MNIST

X = X.reshape(X.shape[0],784) #reshape image data tensor from 60000+784
X_test = X_test.reshape(X_test.shape[0],784)

X = GPU_data(X)
Y = GPU_data(Y)
X_test = GPU_data(X_test)
Y_test = GPU_data(Y_test)

x.shape

X = X.T

x.shape

x = X[:,0:64]

Y[0:64]

plot(x[:,62].reshape(28,28))

batch_size = 64

M = GPU(np.random.rand(10,784))

y = M@x

y = torch.argmax(y,0)

torch.sum((y == Y[0:batch_size]))/batch_size

#### rain random walk model to at least 75% accuracy

m_best = 0
acc_best = 0

for i in range(100000):

    step = 0.0000000001

    m_random = GPU_data(np.random.randn(10,784))

    m = m_best  + step*m_random

    y = m@X

    y = torch.argmax(y, axis=0)

    acc = ((y == Y)).sum()/len(Y)


    if acc > acc_best:
        print(acc.item())
        m_best = m
        acc_best = acc

